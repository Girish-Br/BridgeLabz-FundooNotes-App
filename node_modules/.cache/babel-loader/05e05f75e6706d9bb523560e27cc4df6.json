{"ast":null,"code":"'use strict';\n\nconst events = require('events');\n\nlet handlerProcessor = sequentialHandlerProcessor;\n\nclass EventEmitter extends events.EventEmitter {\n  constructor() {\n    super();\n    this._resultFilter = this._resultFilter || undefined;\n  }\n\n  get maxListeners() {\n    return this.getMaxListeners();\n  }\n\n  set maxListeners(n) {\n    this.setMaxListeners(n);\n  }\n\n  getResultFilter() {\n    return this.resultFilter;\n  }\n\n  setResultFilter(filter) {\n    this.resultFilter = filter;\n    return this;\n  }\n\n  get resultFilter() {\n    return this._resultFilter === undefined && EventEmitter.defaultResultFilter || this._resultFilter;\n  }\n\n  set resultFilter(filter) {\n    if (filter !== undefined && filter !== null && typeof filter !== 'function') {\n      throw new TypeError('Filter must be a function');\n    }\n\n    this._resultFilter = filter;\n  }\n\n  emit(type) {\n    // keep a reference to _resultFilter since the filter function\n    // could theoretically set a new result filter, leading to\n    // undefined results\n    const resultFilter = this.getResultFilter();\n    let er, handlers, len, args, events, domain;\n    let needDomainExit = false;\n    let doError = type === 'error';\n    let emitter = this;\n    let promise;\n    events = this._events;\n\n    if (events) {\n      doError = doError && events.error == null;\n    } else if (!doError) {\n      return Promise.resolve();\n    }\n\n    domain = this.domain; // If there is no 'error' event listener then reject\n\n    if (doError) {\n      er = arguments[1];\n\n      if (er) {\n        if (!(er instanceof Error)) {\n          // At least give some kind of context to the user\n          let err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n          err.context = er;\n          er = err;\n        }\n      } else {\n        er = new Error('Uncaught, unspecified \"error\" event.');\n      }\n\n      if (domain) {\n        er.domainEmitter = this;\n        er.domain = domain;\n        er.domainThrown = false;\n        domain.emit('error', er);\n      }\n\n      return Promise.reject(er);\n    }\n\n    handlers = events[type];\n\n    if (!handlers) {\n      return Promise.resolve();\n    }\n\n    if (domain && this !== process) {\n      domain.enter();\n      needDomainExit = true;\n    }\n\n    if (typeof handlers === 'function') {\n      handlers = [handlers];\n    } else {\n      handlers = handlers.slice();\n    }\n\n    len = arguments.length;\n\n    switch (len) {\n      // fast cases\n      case 1:\n        promise = handlerProcessor(handlers, handler => handler.call(emitter));\n        break;\n\n      case 2:\n        args = arguments;\n        promise = handlerProcessor(handlers, handler => handler.call(emitter, args[1]));\n        break;\n\n      case 3:\n        args = arguments;\n        promise = handlerProcessor(handlers, handler => handler.call(emitter, args[1], args[2]));\n        break;\n\n      case 4:\n        args = arguments;\n        promise = handlerProcessor(handlers, handler => handler.call(emitter, args[1], args[2], args[3]));\n        break;\n      // slower\n\n      default:\n        args = new Array(len - 1);\n\n        for (let i = 1; i < len; ++i) {\n          args[i - 1] = arguments[i];\n        }\n\n        promise = handlerProcessor(handlers, handler => handler.apply(emitter, args));\n    }\n\n    if (needDomainExit) {\n      promise.then(() => domain.exit());\n    }\n\n    if (!resultFilter) {\n      // unfiltered version\n      return promise;\n    } else {\n      return promise.then(results => results.filter(resultFilter));\n    }\n  }\n\n  addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  }\n\n  prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n  }\n\n  once(type, listener) {\n    if (arguments.length === 1) {\n      // return a Promise instance when no callback is given\n      return new Promise(resolve => {\n        this.once(type, resolve);\n      });\n    } else {\n      if (typeof listener !== 'function') {\n        throw new TypeError('\"listener\" argument must be a function');\n      }\n\n      return this.addListener(type, _onceWrap(this, type, listener));\n    }\n  }\n\n  prependOnceListener(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('\"listener\" argument must be a function');\n    }\n\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n  }\n\n  removeListener(type, listener) {\n    let list, events, position;\n    let promise;\n\n    if (typeof listener !== 'function') {\n      throw new TypeError('\"listener\" argument must be a function');\n    }\n\n    events = this._events;\n    list = events && events[type];\n\n    if (!list) {\n      return Promise.resolve();\n    }\n\n    if (list === listener || list.listener && list.listener === listener) {\n      if (--this._eventsCount === 0) {\n        this._events = {};\n      } else {\n        delete events[type];\n\n        if (events.removeListener) {\n          promise = this.emit('removeListener', type, listener);\n        }\n      }\n    } else if (typeof list !== 'function') {\n      position = -1;\n\n      for (let i = list.length; i-- > 0;) {\n        if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n          position = i;\n          break;\n        }\n      }\n\n      if (position < 0) {\n        return Promise.resolve();\n      }\n\n      if (list.length === 1) {\n        list[0] = undefined;\n\n        if (this._eventsCount === 1) {\n          this._events = {};\n          this._eventsCount = 0;\n          return Promise.resolve();\n        } else {\n          delete events[type];\n        }\n      } else {\n        list.splice(position, 1);\n\n        if (list.length === 1) {\n          events[type] = list[0];\n        }\n      }\n\n      --this._eventsCount;\n\n      if (events.removeListener) {\n        promise = this.emit('removeListener', type, listener);\n      }\n    }\n\n    return promise || Promise.resolve();\n  }\n\n  removeAllListeners(type) {\n    let listeners, events;\n    let promise;\n    events = this._events;\n\n    if (!events) {\n      return Promise.resolve();\n    } // not listening for removeListener, no need to emit\n\n\n    if (!events.removeListener) {\n      if (arguments.length === 0) {\n        this._eventsCount = 0;\n        this._events = {};\n      } else if (events[type]) {\n        if (this._eventsCount === 1) {\n          this._eventsCount = 0;\n          this._events = {};\n        } else {\n          this._eventsCount = this._eventsCount - (typeof events[type] === 'function' ? 1 : events[type].length);\n          delete events[type];\n        }\n      }\n\n      return Promise.resolve();\n    } // emit removeListener for all listeners on all events\n\n\n    if (arguments.length === 0) {\n      const keys = Object.keys(events);\n\n      for (let i = 0, key; i < keys.length; ++i) {\n        key = keys[i];\n        if (key === 'removeListener') continue;\n        promise = promise && promise.then(this.removeAllListeners(key)) || this.removeAllListeners(key);\n      }\n\n      promise = promise && promise.then(this.removeAllListeners('removeListener')) || this.removeAllListeners('removeListener');\n      this._events = {};\n      this._eventsCount = 0;\n      return promise || Promise.resolve();\n    }\n\n    listeners = events[type];\n\n    if (typeof listeners === 'function') {\n      promise = this.removeListener(type, listeners);\n    } else if (listeners) {\n      // LIFO order\n      for (let i = listeners.length - 1; i >= 0; --i) {\n        promise = promise && promise.then(this.removeListener(type, listeners[i])) || this.removeListener(type, listeners[i]);\n      }\n    }\n\n    return promise || Promise.resolve();\n  }\n\n}\n\nEventEmitter.EventEmitter = EventEmitter;\nObject.defineProperties(EventEmitter, {\n  defaultMaxListeners: {\n    get: function getDefaultMaxListeners() {\n      return events.EventEmitter.defaultMaxListeners;\n    },\n    set: function setDefaultMaxListeners(n) {\n      events.EventEmitter.defaultMaxListeners = n;\n    }\n  },\n  usingDomains: {\n    get: function getUsingDomains() {\n      return events.EventEmitter.usingDomains;\n    },\n    set: function setUsingDomains(b) {\n      events.EventEmitter.usingDomains = b;\n    }\n  } //sequentialHandlers: {\n  //  get: function getSequentialHandlers() {\n  //    return handlerProcessor === sequentialHandlerProcessor;\n  //  },\n  //  set: function setSequentialHandlers(b) {\n  //    handlerProcessor = b ? sequentialHandlerProcessor : concurrentHandlerProcessor;\n  //  }\n  //}\n\n});\nEventEmitter.defaultResultFilter = undefined;\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype._resultFilter = undefined;\n\nfunction sequentialHandlerProcessor(handlers, callback) {\n  let results = [];\n  return handlers.reduce((promise, handler) => promise.then(() => callback(handler)).then(result => results.push(result)), Promise.resolve()).then(() => results);\n} //function concurrentHandlerProcessor(handlers, callback) {\n//  return Promise.all(handlers.map(handler => {\n//    try {\n//      return callback(handler);\n//    } catch (err) {\n//      return Promise.reject(err);\n//    }\n//  }));\n//}\n\n\nfunction _addListener(target, type, listener, prepend) {\n  let m;\n  let events;\n  let existing;\n  let promise;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('\"listener\" argument must be a function');\n  }\n\n  events = target._events;\n\n  if (!events) {\n    events = target._events = {};\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      promise = target.emit('newListener', type, listener.listener ? listener.listener : listener);\n    }\n\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don\\'t need the extra array object.\n    existing = events[type] = listener;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      existing.push(listener);\n    } // Check for listener leak\n\n\n    if (!existing.warned) {\n      m = target.maxListeners;\n\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        console.error('warning: possible EventEmitter memory ' + 'leak detected. %d %s listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', existing.length, type);\n        console.trace();\n      }\n    }\n  }\n\n  ++target._eventsCount;\n  return promise || Promise.resolve();\n}\n\nfunction _onceWrap(target, type, listener) {\n  let fired = false;\n\n  function g() {\n    if (!fired) {\n      const args = arguments;\n      fired = true;\n      return target.removeListener(type, g).then(() => listener.apply(target, args));\n    }\n  }\n\n  ;\n  g.listener = listener;\n  return g;\n}\n\nmodule.exports = EventEmitter;","map":{"version":3,"sources":["/home/admin-pc/Girish/BridgeLabz-FundooNotes-App/node_modules/promise-events/emitter.js"],"names":["events","require","handlerProcessor","sequentialHandlerProcessor","EventEmitter","constructor","_resultFilter","undefined","maxListeners","getMaxListeners","n","setMaxListeners","getResultFilter","resultFilter","setResultFilter","filter","defaultResultFilter","TypeError","emit","type","er","handlers","len","args","domain","needDomainExit","doError","emitter","promise","_events","error","Promise","resolve","arguments","Error","err","context","domainEmitter","domainThrown","reject","process","enter","slice","length","handler","call","Array","i","apply","then","exit","results","addListener","listener","_addListener","prependListener","once","_onceWrap","prependOnceListener","removeListener","list","position","_eventsCount","splice","removeAllListeners","listeners","keys","Object","key","defineProperties","defaultMaxListeners","get","getDefaultMaxListeners","set","setDefaultMaxListeners","usingDomains","getUsingDomains","setUsingDomains","b","prototype","on","callback","reduce","result","push","target","prepend","m","existing","newListener","warned","console","trace","fired","g","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst events = require('events');\n\nlet handlerProcessor = sequentialHandlerProcessor;\n\n\nclass EventEmitter extends events.EventEmitter {\n  constructor() {\n    super();\n\n    this._resultFilter = this._resultFilter || undefined;\n  }\n\n\n  get maxListeners() {\n    return this.getMaxListeners();\n  }\n\n  set maxListeners(n) {\n    this.setMaxListeners(n);\n  }\n\n\n  getResultFilter() {\n    return this.resultFilter;\n  }\n\n  setResultFilter(filter) {\n    this.resultFilter = filter;\n\n    return this;\n  }\n\n  get resultFilter() {\n    return this._resultFilter === undefined && EventEmitter.defaultResultFilter || this._resultFilter;\n  }\n\n  set resultFilter(filter) {\n    if (filter !== undefined && filter !== null && typeof filter !== 'function') {\n      throw new TypeError('Filter must be a function');\n    }\n\n    this._resultFilter = filter;\n  }\n\n\n  emit(type) {\n    // keep a reference to _resultFilter since the filter function\n    // could theoretically set a new result filter, leading to\n    // undefined results\n    const resultFilter = this.getResultFilter();\n    let er, handlers, len, args, events, domain;\n    let needDomainExit = false;\n    let doError = (type === 'error');\n    let emitter = this;\n    let promise;\n\n    events = this._events;\n\n    if (events) {\n      doError = (doError && events.error == null);\n    } else if (!doError) {\n      return Promise.resolve();\n    }\n\n    domain = this.domain;\n\n    // If there is no 'error' event listener then reject\n    if (doError) {\n      er = arguments[1];\n\n      if (er) {\n        if (!(er instanceof Error)) {\n          // At least give some kind of context to the user\n          let err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n          err.context = er;\n          er = err;\n        }\n      } else {\n        er = new Error('Uncaught, unspecified \"error\" event.');\n      }\n\n      if (domain) {\n        er.domainEmitter = this;\n        er.domain = domain;\n        er.domainThrown = false;\n        domain.emit('error', er);\n      }\n\n      return Promise.reject(er);\n    }\n\n    handlers = events[type];\n\n    if (!handlers) {\n      return Promise.resolve();\n    }\n\n    if (domain && this !== process) {\n      domain.enter();\n      needDomainExit = true;\n    }\n\n    if (typeof handlers === 'function') {\n      handlers = [handlers];\n    } else {\n      handlers = handlers.slice();\n    }\n\n    len = arguments.length;\n    switch (len) {\n      // fast cases\n      case 1:\n        promise = handlerProcessor(handlers, handler => handler.call(emitter));\n        break;\n      case 2:\n        args = arguments;\n        promise = handlerProcessor(handlers, handler => handler.call(emitter, args[1]));\n        break;\n      case 3:\n        args = arguments;\n        promise = handlerProcessor(handlers, handler => handler.call(emitter, args[1], args[2]));\n        break;\n      case 4:\n        args = arguments;\n        promise = handlerProcessor(handlers, handler => handler.call(emitter, args[1], args[2], args[3]));\n        break;\n      // slower\n      default:\n        args = new Array(len - 1);\n        for (let i = 1; i < len; ++i) {\n          args[i - 1] = arguments[i];\n        }\n        promise = handlerProcessor(handlers, handler => handler.apply(emitter, args));\n    }\n\n    if (needDomainExit) {\n      promise.then(() => domain.exit());\n    }\n\n    if (!resultFilter) {\n      // unfiltered version\n      return promise;\n    } else {\n      return promise.then(results => results.filter(resultFilter));\n    }\n  }\n\n\n  addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  }\n\n  prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n  }\n\n  once(type, listener) {\n    if (arguments.length === 1) {\n      // return a Promise instance when no callback is given\n      return new Promise(resolve => {\n        this.once(type, resolve);\n      });\n    } else {\n      if (typeof listener !== 'function') {\n        throw new TypeError('\"listener\" argument must be a function');\n      }\n\n      return this.addListener(type, _onceWrap(this, type, listener));\n    }\n  }\n\n  prependOnceListener(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('\"listener\" argument must be a function');\n    }\n\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n  }\n\n  removeListener(type, listener) {\n    let list, events, position;\n    let promise;\n\n    if (typeof listener !== 'function') {\n      throw new TypeError('\"listener\" argument must be a function');\n    }\n\n    events = this._events;\n    list = events && events[type];\n\n    if (!list) {\n      return Promise.resolve();\n    }\n\n    if (list === listener || (list.listener && list.listener === listener)) {\n      if (--this._eventsCount === 0) {\n        this._events = {};\n      } else {\n        delete events[type];\n\n        if (events.removeListener) {\n          promise = this.emit('removeListener', type, listener);\n        }\n      }\n    } else if (typeof list !== 'function') {\n      position = -1;\n\n      for (let i = list.length; i-- > 0;) {\n        if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n          position = i;\n          break;\n        }\n      }\n\n      if (position < 0) {\n        return Promise.resolve();\n      }\n\n      if (list.length === 1) {\n        list[0] = undefined;\n\n        if (this._eventsCount === 1) {\n          this._events = {};\n          this._eventsCount = 0;\n\n          return Promise.resolve();\n        } else {\n          delete events[type];\n        }\n      } else {\n        list.splice(position, 1);\n\n        if (list.length === 1) {\n          events[type] = list[0];\n        }\n      }\n      --this._eventsCount;\n\n      if (events.removeListener) {\n        promise = this.emit('removeListener', type, listener);\n      }\n    }\n\n    return promise || Promise.resolve();\n  }\n\n\n  removeAllListeners(type) {\n    let listeners, events;\n    let promise;\n\n    events = this._events;\n\n    if (!events) {\n      return Promise.resolve();\n    }\n\n    // not listening for removeListener, no need to emit\n    if (!events.removeListener) {\n      if (arguments.length === 0) {\n        this._eventsCount = 0;\n        this._events = {};\n      } else if (events[type]) {\n        if (this._eventsCount === 1) {\n          this._eventsCount = 0;\n          this._events = {};\n        } else {\n          this._eventsCount = this._eventsCount - (typeof events[type] === 'function' ? 1 : events[type].length);\n          delete events[type];\n        }\n      }\n\n      return Promise.resolve();\n    }\n\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n      const keys = Object.keys(events);\n\n      for (let i = 0, key; i < keys.length; ++i) {\n        key = keys[i];\n        if (key === 'removeListener') continue;\n\n        promise = promise && promise.then(this.removeAllListeners(key)) || this.removeAllListeners(key);\n      }\n\n      promise = promise && promise.then(this.removeAllListeners('removeListener')) || this.removeAllListeners('removeListener');\n      this._events = {};\n      this._eventsCount = 0;\n\n      return promise || Promise.resolve();\n    }\n\n    listeners = events[type];\n\n    if (typeof listeners === 'function') {\n      promise = this.removeListener(type, listeners);\n    } else if (listeners) {\n      // LIFO order\n      for (let i = listeners.length - 1; i >= 0; --i) {\n        promise = promise && promise.then(this.removeListener(type, listeners[i])) || this.removeListener(type, listeners[i]);\n      }\n    }\n\n    return promise || Promise.resolve();\n  }\n\n}\n\n\nEventEmitter.EventEmitter = EventEmitter;\n\nObject.defineProperties(EventEmitter, {\n  defaultMaxListeners: {\n    get: function getDefaultMaxListeners() {\n      return events.EventEmitter.defaultMaxListeners;\n    },\n    set: function setDefaultMaxListeners(n) {\n      events.EventEmitter.defaultMaxListeners = n;\n    }\n  },\n  usingDomains: {\n    get: function getUsingDomains() {\n      return events.EventEmitter.usingDomains;\n    },\n    set: function setUsingDomains(b) {\n      events.EventEmitter.usingDomains = b;\n    }\n  },\n  //sequentialHandlers: {\n  //  get: function getSequentialHandlers() {\n  //    return handlerProcessor === sequentialHandlerProcessor;\n  //  },\n  //  set: function setSequentialHandlers(b) {\n  //    handlerProcessor = b ? sequentialHandlerProcessor : concurrentHandlerProcessor;\n  //  }\n  //}\n});\n\nEventEmitter.defaultResultFilter = undefined;\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype._resultFilter = undefined;\n\n\nfunction sequentialHandlerProcessor(handlers, callback) {\n  let results = [];\n  return handlers.reduce((promise, handler) => promise.then(() => callback(handler)).then(result => results.push(result)), Promise.resolve()).then(() => results);\n}\n\n//function concurrentHandlerProcessor(handlers, callback) {\n//  return Promise.all(handlers.map(handler => {\n//    try {\n//      return callback(handler);\n//    } catch (err) {\n//      return Promise.reject(err);\n//    }\n//  }));\n//}\n\n\nfunction _addListener(target, type, listener, prepend) {\n  let m;\n  let events;\n  let existing;\n  let promise;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('\"listener\" argument must be a function');\n  }\n\n  events = target._events;\n\n  if (!events) {\n    events = target._events = {};\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      promise = target.emit('newListener', type, listener.listener ? listener.listener : listener);\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don\\'t need the extra array object.\n    existing = events[type] = listener;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      existing.push(listener);\n    }\n    // Check for listener leak\n    if (!existing.warned) {\n      m = target.maxListeners;\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        console.error('warning: possible EventEmitter memory ' +\n          'leak detected. %d %s listeners added. ' +\n          'Use emitter.setMaxListeners() to increase limit.',\n          existing.length, type);\n        console.trace();\n      }\n    }\n  }\n  ++target._eventsCount;\n\n  return promise || Promise.resolve();\n}\n\nfunction _onceWrap(target, type, listener) {\n  let fired = false;\n\n  function g() {\n    if (!fired) {\n      const args = arguments;\n\n      fired = true;\n\n      return target.removeListener(type, g).then(() => listener.apply(target, args));\n    }\n  };\n\n  g.listener = listener;\n\n  return g;\n}\n\nmodule.exports = EventEmitter;\n"]},"metadata":{},"sourceType":"script"}